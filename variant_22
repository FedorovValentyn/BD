/*ЕКЗАМЕНАЦІЙНИЙ БІЛЕТ № 22
1. Типи індексів. Способи завдання індексів. (10 балів)

Індекс може бути або кластеризованим, або не кластеризованим,
також його можна додатково налаштувати як складений індекс, унікальний індекс або покриваючий індекс.

Кластеризований індекс.
Кластеризований індекс зберігає реальні рядки даних у листках індексу.
Це означає, що рядок даних, пов'язаний зі значенням ключа, наприклад,
123, буде зберігатися безпосередньо в індексі. Важливою особливістю кластеризованого
індексу є те, що всі значення впорядковані в певному порядку, будь то за зростанням чи
за спаданням. Таким чином, таблиця чи представлення може мати тільки один кластеризований
індекс. Таблиця без кластеризованого індексу називається "кучею".

Не кластеризований індекс.
На відміну від кластеризованого індексу, листки не кластеризованого
індексу містять лише ті ключові стовбці, за якими визначено цей індекс,
а також вказівник на рядки із реальними даними в таблиці. Це означає,
що для системи підзапитів потрібна додаткова операція для виявлення та
отримання необхідних даних. Зміст вказівника на дані залежить від того,
як зберігаються дані: чи це кластеризована таблиця чи куча. Якщо вказівник
спрямовується на кластеризовану таблицю, він веде до кластеризованого індексу,
за допомогою якого можна знайти реальні дані. Якщо вказівник спрямовується на кучу,
він вказує на конкретний ідентифікатор рядка з даними. Не кластеризовані індекси не
можуть бути впорядковані, на відміну від кластеризованих. Проте ви можете створити більше одного
не кластеризованого індексу на таблиці чи представленні, аж до 999. Це не означає, що вам слід створювати
якнайбільше індексів, оскільки вони можуть покращити або погіршити продуктивність системи. Додатково
до можливості створити кілька не кластеризованих індексів, ви також можете включити додаткові стовбці
(включені стовбці) у свій індекс: листки індексу будуть містити не тільки значення індексованих стовбців,
але й значення цих додаткових не індексованих стовбців. Цей підхід дозволяє обійти деякі обмеження,
накладені на індекс. Наприклад, ви можете включити не індексований стовбець або обійти обмеження на довжину
індексу (900 байт у більшості випадків).

Складений індекс.
Такий індекс може включати більше одного стовбця. Ви можете включити до 16 стовбців у складений індекс,
але їхня загальна довжина обмежена 900 байтами. Як кластеризовані, так і не кластеризовані індекси можуть бути складеними.

Унікальний індекс.
Такий індекс забезпечує унікальність кожного значення в індексованому стовбці. Якщо індекс є складеним,
унікальність поширюється на всі стовбці індексу, а не на кожен окремий стовбець. Наприклад, якщо ви створите
унікальний індекс на стовбцях ІМ'Я і ФАМІЛІЯ, то повне ім'я повинно бути унікальним, але окремо можуть
існувати дублі у імені або фамілії. Унікальний індекс автоматично створюється, коли ви визначаєте обмеження
стовбця: первинний ключ або обмеження на унікальні значення:
Первинний ключ: Коли ви визначаєте обмеження першочергового ключа для одного чи кількох стовбців,
SQL Server автоматично створює унікальний кластеризований індекс, якщо раніше не був створений
кластеризований індекс (в цьому випадку створюється унікальний не кластеризований індекс для першочергового ключа).
Унікальність значень: Коли ви визначаєте обмеження на унікальність значень, SQL Server автоматично створює
унікальний не кластеризований індекс. Ви можете вказати створення унікального кластеризованого індексу,
якщо до цього часу на таблиці не було створено кластеризованого індексу.

Покриваючий індекс.
Такий індекс дозволяє конкретному запиту одразу отримати всі необхідні дані з листів індексу без додаткових обробок записів самої таблиці.


2. Значення та синтаксис функції IF(), приклад. (10 балів)

Функція IF() використовується для визначення умови та повернення різних значень
в залежності від цієї умови. Ось синтаксис цієї функції:
IF(condition, value_if_true, value_if_false)
Ця функція приймає три аргументи:
condition – умова, яку потрібно перевірити.
value_if_true – значення, яке повернеться, якщо умова виконується.
value_if_false – значення, яке повернеться, якщо умова не виконується.

Наприклад, якщо потрібно перевірити, чи є число x більше 0 і повернути різні рядки
у залежності від цієї умови, можна використати IF():
SELECT IF(x > 0, 'Positive', 'Not Positive') AS result;


3. Практичне завдання (20 балів).
Відповідно до виданих таблиць створити в MySQL базу даних.
Створити до бази наступні запити:
 запит про не сплачені замовлення товарів на 12.08.2004. Динамічний набір
записів повинен містити такі поля: Номер замовлення, Назва фірми, Адреса,
Дата замовлення, Дата сплати.
 груповий запит, що виводить загальну вартість товарів, у яких кількість
менше за середню кількість по всім продажам.
 перехресний запит, який би відтворювався наступною таблицею:
Назва фірми 07 2004 08 2004
Івано-Франківська
торгово-проми-слова
палата
Загальна вартість Загальна вартість
… … …
СП “Ліссервіс” Загальна вартість Загальна вартість
Вартість розраховуються як добуток ціни товару на кількість замовленого товару. Якщо
Вид замовлення “Самовивіз”, то ціна зменшується на 3,5%, в іншому випадку - ціна
залишається незмінною*/

CREATE DATABASE variant_22;

USE variant_22;


CREATE TABLE firms(
    firm_id INT PRIMARY KEY,
    firm_name VARCHAR(55),
    firm_address VARCHAR(55),
    firm_code VARCHAR(55)
);

CREATE TABLE orders(
    order_id INT PRIMARY KEY,
    order_firm_id INT,
    order_type_id INT,
    order_date DATE,
    order_payment_date DATE
);

CREATE TABLE items(
    item_id INT PRIMARY KEY,
    item_name VARCHAR(55),
    item_price INT
);

CREATE TABLE contracts(
    contract_uniq INT PRIMARY KEY AUTO_INCREMENT,
    contract_order_id INT,
    contract_item_id INT,
    contract_quantity INT
);

CREATE TABLE types(
    type_id INT PRIMARY KEY,
    type_name VARCHAR(55)
);

ALTER TABLE orders
ADD CONSTRAINT order_firm_id_fk
FOREIGN KEY (order_firm_id) REFERENCES firms(firm_id),
ADD CONSTRAINT order_type_id_fk
FOREIGN KEY (order_type_id) REFERENCES types(type_id);


ALTER TABLE contracts
ADD CONSTRAINT contract_order_id_fk
FOREIGN KEY (contract_order_id) REFERENCES orders(order_id),
ADD CONSTRAINT contract_item_id_fk
FOREIGN KEY (contract_item_id) REFERENCES items(item_id);


#1
SELECT  order_id AS "Номер замовлення",  firm_name AS "Назва фірми", firm_address AS "Адреса",  order_date AS "Дата замовлення",
        order_payment_date AS "Дата сплати"

FROM    orders

JOIN    firms ON order_firm_id = firm_id

WHERE   order_payment_date IS NULL  AND order_date <= '2004-08-12';

#2
SELECT  item_id AS "ID товару",
        item_name AS "Назва товару",
        SUM(IF(type_id = 2, contract_quantity * item_price * 0.965, contract_quantity * item_price)) AS "Загальна вартість"
FROM contracts
JOIN items ON contract_item_id = item_id
JOIN orders ON contract_order_id = order_id
JOIN types ON order_type_id = type_id
WHERE contract_quantity < (SELECT AVG(contract_quantity) FROM contracts)
GROUP BY item_id;

#3
SELECT
    firm_name AS "Назва фірми",
    SUM(CASE
        WHEN MONTH(order_date) = 7 AND YEAR(order_date) = 2004
        THEN IF(type_id = 2, contract_quantity * item_price * 0.965, contract_quantity * item_price) END) AS "07 2004",
    SUM(CASE
        WHEN MONTH(order_date) = 8 AND YEAR(order_date) = 2004
        THEN IF(type_id = 2, contract_quantity * item_price * 0.965, contract_quantity * item_price) END) AS "08 2004"

FROM firms

JOIN orders ON firm_id = order_firm_id
JOIN contracts ON order_id = contract_order_id
JOIN items ON contract_item_id = item_id
JOIN types ON order_type_id = type_id

GROUP BY firm_name;